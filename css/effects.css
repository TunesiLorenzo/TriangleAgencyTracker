/* effects.css - overlays, scanlines, death overlay, scanline element */

/* Death overlay */
.death-overlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 32px;
  font-weight: bold;
  color: red;
  opacity: 0;
  pointer-events: none;
  font-family: 'ITCAvantGarde', sans-serif;
  transform: rotate(0deg);
  text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
}
.death-overlay::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.6);
  z-index: -1;
  border-radius: inherit;
}
.char.dead {
  background-color: rgba(0,0,0,0.2) !important;
  color: rgba(255,255,255,0.4);
}
.char.dead .death-overlay { opacity: 1; }

/* CRT scanline element (single bright line controlled by JS) */
#crtScanline {
  position: fixed;
  left: 0;
  width: 100%;
  height: 50px;
  background: rgba(255,255,255,0);
  box-shadow: 0 0 8px rgba(255,255,255,0);
  pointer-events: none;
  z-index: 9999;
  bottom: 0;
}

/* full-screen scanline overlay */
#scanlineOverlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  width: calc(100vw + 0px);
  height: calc(100vh + 0px);
  z-index: 9998;
  background-image: repeating-linear-gradient(
    to bottom,
    rgba(255,50,50,0.25) 0px,
    rgba(255,50,50,0.25) 4px,
    rgba(0,0,0,1) 4px,
    rgba(0,0,0,1) 10px
  );
  opacity: 0;
  mix-blend-mode: overlay;
  transition: opacity 0.2s linear;
  background-size: auto;
}

/* noise overlay (canvas element #noiseOverlay assumed) */
#noiseOverlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9997;
  mix-blend-mode: multiply; /* can be switched in JS */
  opacity: 0.15; /* default */
}

/* scanline / triangle pop animation */
.triangle.animate, .triangle-down.animate { animation: pop 0.5s ease-out; }
@keyframes pop {
  0% { transform: scale(1); }
  30% { transform: scale(1.5); }
  100% { transform: scale(1); }
}

/*FLIP LOGIC*/
/* ---------- Card flip/structure ---------- */
.char {
  position: relative;
  width: 260px;             /* adjust to your card size */
  height: 360px;            /* adjust to your card size */
  perspective: 1000px;
  -webkit-perspective: 1000px;
  transition: transform 300ms ease;
  overflow: visible;
}

/* treat everything except .backFace as the front content */
.char > *:not(.backFace) {
  transform-origin: 50% 50%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 320ms;
}

/* back face styling (initially hidden, rotated) */
.char .backFace {
  position: absolute;
  inset: 8px;
  margin: 0;
  padding: 12px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 10px;
  transform: rotateY(180deg);
  transform-origin: 50% 50%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  opacity: 0;
  pointer-events: none;
  border-radius: 10px;
  z-index: 20;
  transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 320ms;
  /* Removed explicit background so .char.merit/.demerit rules control color */
  background: transparent;
  /* If you want a subtle card chrome, use box-shadow only (not background color) */
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  overflow: auto;
}

.char.flipped .backFace {
  transform: rotateY(0deg);
  opacity: 1;
  pointer-events: auto;
}

/* ensure front content becomes visually hidden but not the flip control */
.char.flipped > *:not(.backFace):not(.flip-btn) {
  transform: rotateY(180deg);
  opacity: 0;
  pointer-events: none;
}

/* ---------- Back-face subboxes overlay ---------- */
.back-subbox {
  position: relative;
  display: flex;
  flex-direction: column;
  padding: 8px;
  border-radius: 8px;
  min-height: 90px;
  background-clip: padding-box;
  box-shadow: inset 0 2px 4px rgba(255,255,255,0.05),
              0 4px 16px rgba(0,0,0,0.4); /* stronger outer shadow */
}

.back-subbox::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 8px;
  background: rgba(0,0,0,0.15); /* more visible overlay */
  pointer-events: none;
  z-index: 1;
}
/* ---------- textboxes (centered, look like normal text until focus) ---------- */
.back-textwrap {
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: center; /* vertical center */
  align-items: center;     /* horizontal center */
  z-index: 2;              /* above overlay */
  width: 100%;
  height: 100%;
}

.back-text {
  width: 90%;
  min-height: 48px;
  max-height: 140px;
  padding: 4px 6px;
  border-radius: 6px;
  border: none;
  background: transparent;
  color: inherit;
  font-size: 13px;
  text-align: center;      /* center text horizontally */
  line-height: 1.3;
  resize: none;
  cursor: text;
  transition: background 0.2s, color 0.2s, box-shadow 0.2s;
}

/* look like normal text when not focused */
.back-text:not(:focus) {
  background: transparent;
  box-shadow: none;
  border: none;
  cursor: pointer;
  pointer-events: auto; /* still allow click to focus */
}

/* subtle highlight when focused */
.back-text:focus {
  background: rgba(255,255,255,0.05);
  box-shadow: 0 0 4px rgba(255,255,255,0.15);
  outline: none;
}


/* Keep color/tint behavior: backFace will inherit classes copied from .char */
/* Example: .char.merit .backFace { ... } handled by your existing CSS variables */

/* ---------- Flip button ---------- */

.flip-btn {
  position: absolute;
  top: 8px;
  right: 36px;
  z-index: 60;             /* above backFace */
  width: 28px;
  height: 28px;
  border-radius: 6px;
  border: none;
  background: rgba(255,255,255,0.06);
  color: var(--ui-foreground, #ddd);
  cursor: pointer;
  font-size: 14px;
  display: grid;
  place-items: center;
  transition: transform 160ms;
  /* ensure it doesn't get rotated with the front content */
  transform-style: preserve-3d;
  backface-visibility: visible;
  -webkit-backface-visibility: visible;
}
.flip-btn:hover { transform: scale(1.05); }
/* ---------- Back face subboxes (Prime / Encouraged) ---------- */
.backFace { gap: 12px; }

/* container for each action */
.back-subbox {
  display: flex;
  flex-direction: column;
  padding: 8px;
  border-radius: 8px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
  min-height: 90px;
}

/* color variants (use your CSS vars; fallback values included) */
.back-subbox.prime {
  background: linear-gradient(180deg, rgba(200,40,40,0.08), rgba(200,40,40,0.03));
  border: 1px solid rgba(200,40,40,0.12);
}
.back-subbox.encouraged {
  background: linear-gradient(180deg, rgba(40,200,100,0.06), rgba(40,200,100,0.02));
  border: 1px solid rgba(40,200,100,0.12);
}

/* the big action button at the top of each subbox */
.back-action-btn {
  align-self: stretch;
  padding: 8px 10px;  /* slightly bigger padding */
  border-radius: 6px;
  border: none;
  font-weight: 700;
  font-size: 16px;      /* bigger font */
  cursor: pointer;
  margin-bottom: 6px;
  background: rgba(255,255,255,0.06);
  color: inherit;
  transition: transform 140ms ease, box-shadow 140ms;
}

.back-action-btn:active { transform: translateY(1px) scale(0.995); }

/* textarea wrapper and textarea */
.back-textwrap { display: block; width: 100%; }
.back-text {
  width: 100%;
  resize: vertical;
  min-height: 48px;
  max-height: 140px;
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.25);
  background: rgba(0,0,0,0.45);
  color: var(--ui-foreground, #eee);
  font-size: 13px;
  line-height: 1.2;
  box-sizing: border-box;
}

/* small niceties */
.char .death-overlay { z-index: 30; } /* so death overlay still sits above back if needed */
.char .remove-btn { z-index: 40; }    /* keep remove clickable */

/* preserve tilt/transform visual when top classes are applied
   (these selectors assume you already have CSS for .tilt, .star, .merit/.demerit) */
.char.star, .char.top-merit { /* example enhancement for star effect */ }
.char.tilt, .char.crooked { /* example enhancement for tilt effect */ }

/* responsive tweak: ensure backFace content scrolls if overflowing */
.backFace { overflow: auto; padding-bottom: 14px; }

/* focus accessibility */
.back-action-btn:focus, .back-text:focus, .flip-btn:focus { outline: 2px solid rgba(255,255,255,0.08); outline-offset: 2px; }

/* Best Worst Agent behavior*/
/* ensure char boxes can contain absolute overlays */
<style>

/* star/thumb visuals retained from before; we add shine */
.thumb {
  position: absolute;
  right: 6px;
  top: 6px;
  font-size: 18px;
  pointer-events: none;
  user-select: none;
}

/* Ensure char is the clipping & positioning container */
.char {
  position: relative;    /* already required */
  overflow: hidden;      /* <-- clip shine and broken overlays to the char box */
  /* keep display / sizing as you already have it */
}

/* Shrink the shine overlay so it only sweeps across the char area */
.shine-overlay {
  position: absolute;
  /* replace the giant size with a thin, narrow strip centered vertically */
  left: -120%;           /* start well off-left so transform covers entire sweep */
  top: 0%;              /* adjust vertical placement within the char */
  width: 340%;           /* wide enough to sweep corner-to-corner, but limited */
  height: 100%;           /* cover most of the char's height but not overflow */
  pointer-events: none;
  mix-blend-mode: screen;
  opacity: 0;            /* animation controls visibility */
  transform: skewX(-18deg) translateX(-100%);
  background: linear-gradient(
    90deg,
    rgba(255,255,255,0.00) 0%,
    rgba(255,255,255,0.65) 45%,
    rgba(255,255,255,0.10) 55%,
    rgba(255,255,255,0.00) 100%
  );
  animation: shine-sweep 2.5s linear infinite;
}

/* only show the shine overlay when the char is the top merit */
.char:not(.top-merit) .shine-overlay { display: none; }

/* Tighter keyframes so the strip sweeps across the char box */
@keyframes shine-sweep {
  0%   { transform: skewX(-18deg) translateX(-100%); opacity: 0; }
  10%  { opacity: 0.9; }
  50%  { transform: skewX(-18deg) translateX(0%); opacity: 0.6; }
  90%  { opacity: 0; }
  100% { transform: skewX(-18deg) translateX(100%); opacity: 0; }
}




/* Ensure char is the clipping & positioning container */
.char {
  position: relative;
  overflow: hidden;   /* clip overlays to the char box */
}

/* DARK VIGNETTE overlay that normally darkens the char box */
.vignette-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 30;
  mix-blend-mode: multiply; /* darken content underneath */
  /* radial gradient: subtle center visibility, strong dark edges */
  background: radial-gradient(
    circle at 50% 40%,
    rgba(0,0,0,0.20) 0%,
    rgba(0,0,0,0.45) 30%,
    rgba(0,0,0,0.75) 65%,
    rgba(0,0,0,0.95) 100%
  );
  /* base opacity (how strongly it darkens) â€” high value = darker */
  opacity: 0.88;
  filter: blur(6px) saturate(0.9);
  transform-origin: center;
  will-change: opacity, transform;
  /* two animations:
     - flicker (short irregular dips in opacity -> momentary illumination)
     - breathe (slow subtle movement so it doesn't feel static)
  */
  animation:
    vignette-flicker-dark 1.15s steps(6, end) infinite,
    vignette-breathe 3.8s ease-in-out infinite;
}

/* Only show the vignette on the top-demerit char */
.char:not(.top-demerit) .vignette-overlay { display: none; }

/* Flicker: stays mostly opaque, with short drops to reveal the char */
@keyframes vignette-flicker-dark {
  0%   { opacity: 0.90; transform: scale(1); }
  6%   { opacity: 0.88; }
  10%  { opacity: 0.32; transform: scale(1.005); } /* quick bright flash */
  18%  { opacity: 0.86; transform: scale(0.997); }
  30%  { opacity: 0.30; transform: scale(1.01); }  /* another flash */
  45%  { opacity: 0.92; transform: scale(1); }
  62%  { opacity: 0.80; transform: scale(0.998); }
  75%  { opacity: 0.28; transform: scale(1.02); }  /* big illumination */
  88%  { opacity: 0.88; transform: scale(0.995); }
  100% { opacity: 0.90; transform: scale(1); }
}

/* Slow breathing to add weight */
@keyframes vignette-breathe {
  0%   { filter: blur(5px) saturate(0.9); transform: scale(1); }
  50%  { filter: blur(8px) saturate(0.95); transform: scale(1.01); }
  100% { filter: blur(5px) saturate(0.9); transform: scale(1); }
}

/* Maintain tilt but keep overlay positioned correctly */
.char.top-demerit.crooked {
  transform-origin: 50% 50%;
  transition: transform 0.25s ease;
  transform: rotate(-3.5deg) translateY(2px);
}

/* quick mobile fallback: reduce intensity and animation load */
@media (max-width: 600px) {
  .vignette-overlay {
    opacity: 0.82;
    animation-duration: 1.6s, 4.4s;
    filter: blur(4px) saturate(0.85);
  }
}


</style>
